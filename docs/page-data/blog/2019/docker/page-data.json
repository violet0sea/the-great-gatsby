{"componentChunkName":"component---src-templates-blog-js","path":"/blog/2019/docker","result":{"data":{"markdownRemark":{"html":"<h3>docker 介绍</h3>\n<p>Docker 采用虚拟化技术（操作系统虚拟化），可以让开发人员在 Container 里开发，部署，运行应用。将开发代码与环境隔离，在隔离容器中运行，避免了由于环境问题导致的各类问题。Docker之前使用虚拟机来做隔离，由于虚拟机占用较多的资源，导致资源利用率低，而且虚拟机里安装了独立的操作系统，进而使得启动速度较慢；基于以上的原因，linux一致在致力于容器技术的开发，而Docker正是利用LXC技术来实现了简单易用的API。\n如何在项目里引入Docker呢？思路如下：\n构建一个 image ---> 在 container 里运行 ---> 对 image 和 container 进行管理</p>\n<h3>特点</h3>\n<p>快速部署\n轻量\n易于迁移和扩展\n性能高开销小</p>\n<h3>应用场景</h3>\n<p>自动化部署\n微服务</p>\n<h3>docker Engine</h3>\n<p>CS 架构\ndocker image\ndocker container</p>\n<h4>Dockerfile</h4>\n<p>构建 image 的基本组成，包含一系列的指令的文本文件，可以使用 docker build 命令来创建</p>\n<pre><code>指令格式\nINSTRUCTION arguments\n</code></pre>\n<ul>\n<li>FROM 定义构建时需要使用的 base image</li>\n<li>LABEL 添加 image 的元数据信息</li>\n<li>ARG 设置构建时的变量</li>\n<li>ENV 设置环境变量</li>\n<li>WORKDIR 定义容器内的工作目录，在使用 COPY | ADD 等命令时可以使用.代替</li>\n<li>RUN 构建过程中需要执行的命令</li>\n<li>COPY 复制本地文件到容器</li>\n<li>ADD 复制文件、目录、以及远程文件的 urls 到导致</li>\n<li>VOLUME 将宿主机器的目录挂载到容器目录里，适合配置文件，开发环境的代码</li>\n<li>ENTRYPOINT 设置容器运行时需要执行的命令和参数</li>\n<li>CMD 容器运行时需要执行的默认命令，在 ENTRYPOINT 之后执行</li>\n<li>EXPOSE 定义容器运行时的端口</li>\n</ul>\n<h4>DockerCLI</h4>\n<p>docker build 使用 Dockerfile 文件构建 image\ndocker run 使用 image 运行一个容器\ndocker exec 进入容器内部\ndocker images 查看已存在的镜像\ndocker ps 查看当前正在运行的容器\ndocker rm 删除容器\ndocker rmi 删除镜像\ndocker start | stop | restart | kill 启动、停止、重启、杀死容器\ndocker push 将本地的镜像推送到 docker hub\ndocker pull 从 docker hub 上下载镜像</p>\n<h4>制作一个镜像</h4>\n<ol>\n<li>使用 nginx</li>\n</ol>\n<h4>Docker-Compose</h4>\n<p>单个容器使用 Dockerfile 足够，运行多容器应用需要 compose，使用 docker-compose.yml来启动多个容器，一个简单的node例子</p>\n<pre><code># docker-compose.yml\nversion: \"3\"\nservices:\n  webapp:\n    build: .\n    ports:\n      - \"3006:3006\"\n    volumes:\n      - .:/code\n    depends_on:\n      - redis\n      - mongo\n  redis:\n    image: \"redis:alpine\"\n  mongo:\n    image: \"mongo:4.0\"\n\n# app.js\nconst http = require('http');\nconst redis = require('redis');\nconst mongoose = require(\"mongoose\")\n\nconst client = redis.createClient(6379, 'redis')\nclient.on('connect', function () {\n  client.set('count', 1)\n  console.log('connected');\n});\n\nmongoose.connect(\"mongodb://mongo/test\", { useNewUrlParser: true })\n\nconst kittySchema = new mongoose.Schema({\n  date: String\n})\n\nconst Kitten = mongoose.model(\"Kitten\", kittySchema)\n\nconst server = http.createServer(function (req, res) {\n  const silence = new Kitten({ date: new Date() })\n  if (req.url === '/') {\n    client.get('count', function (err, count) {\n      res.write(\n        \"It's works. \\n The site have been visited  \" +\n          count +\n          \" times.\" +\n          \"silence \" +\n          silence.date\n      )\n      res.end()\n      client.set('count', parseInt(count) + 1)\n    });\n  }\n\n\n})\n\nserver.listen(3006, function () {\n  console.log('server running at port 3006.')\n})\n\n# Dockerfile\nFROM node:10\nWORKDIR /code\nCMD [\"node\", \"app.js\"]\n\n# package.json\n{\n  \"name\": \"docker-node\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &#x26;&#x26; exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"mongoose\": \"^5.5.6\",\n    \"redis\": \"^2.8.0\"\n  }\n}\n</code></pre>","frontmatter":{"title":"docker"}}},"pageContext":{"slug":"/blog/2019/docker/"}}}