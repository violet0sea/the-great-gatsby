{"componentChunkName":"component---src-templates-blog-js","path":"/blog/2019/jsinherit","result":{"data":{"markdownRemark":{"html":"<p>继承是 JavaScript 里重要的知识点，在JavaScript的世界里，并不存在类，所以其继承的形式和其他语言（Java）相比，存在很大的区别；在JS的世界里，对象和对象之间的关系是通过一个内部的<strong>[[prototype]]</strong>链接的，在各个浏览器里可以通过<em><strong>proto</strong></em>来查看。</p>\n<p>需要注意的是<strong>[[prototype]]</strong>是内部属性，无法获取，<strong>proto</strong>原本是浏览器私自实现的，后来在es6中被列入规范</p>\n<p>说了这么多，如何感知到这个链接的存在，亦或是这个链接能带来什么呢？举个例子，当我们在获取一个对象上的属性或者方法时，如果这个对象或者方法不存在于当前对象，这个时候原型链就起作用了；比如我们常常使用数字的toFixed方法：</p>\n<pre><code>const PI = 3.1415926;\nPI.toFixed(2); // \"3.14\" 数字本身不存在这个方法，这里就是通过原型链来取得的，这里实际上时JS引擎对基本类型做了一层包装，使其变成对象类型然后在调用原型上的方法\n</code></pre>\n<h3>基本思想</h3>\n<blockquote>\n<p>利用原型让一个引用类型继承另一个引用类型的属性和方法</p>\n</blockquote>\n<h4>原型链继承</h4>\n<pre><code>function Animal() {\n    this.property = 'property';\n}\n\nAnimal.prototype.getProperty = function() {\n    console.log(this.property);\n};\n\nfunction Cat() {\n    this.sound = 'meow';\n}\n\n// Cat继承Animal时通过创建Animal的实例实现\nCat.prototype = new Animal(); // 此处会导致默认的Cat.prototype.constructor消失\nCat.prototype.getsound = function() {\n    console.log(this.sound);\n};\n\nvar nimo = new Cat();\nconsole.log(nimo.getProperty());\n</code></pre>\n<h4>确定原型和实例的关系</h4>\n<p>确定原型和实例之间的关系，通常采用下面两种方式：</p>\n<ol>\n<li>instanceof</li>\n<li>isPrototypeof()</li>\n</ol>\n<p>切记，不要使用constructor属性，由于构造函数的原型很容易被替换成新的对象，这种情况下constructor属性指向不正确，无法判定两者之间的关系</p>\n<pre><code>nimo instanceof Cat // true\nnimo instanceof Animal // true\nnimo instanceof Object // true\n\nCat.prototype.isPrototypeOf(nimo) // true\nAnimal.prototype.isPrototypeOf(nimo) // true\nObject.prototype.isPrototypeOf(nimo) // true\n</code></pre>\n<h4>缺点</h4>\n<p>当原型链包含引用类型值时，值的变化会影响到所有的实例\n在创建子类的实例时，不能向超类的构造函数传递参数</p>\n<h3>构造函数继承</h3>\n<p>为了解决原型中包含引用类型值时所带来的影响；通过在子类型构造函数内部调用超类型构造函数来实现。</p>\n<pre><code>function Animal(species) {\n    this.species = species;\n    this.hobits = ['eat', 'sleep', 'play'];\n}\n\nfunction Cat() {\n    Animal.call(this, 'cat');\n    // todo 调用之后在添加子类实例的属性\n}\n\nconst nimo = new Cat();\nnimo.hobits.push('meow');\nconsole.log(nimo.hobits);\n\nconst niya = new Cat();\nconsole.log(niya.hobits);\n</code></pre>\n<p>此外还有一个好处，可以向父类构造函数传递参数</p>\n<h4>缺点</h4>\n<p>构造函数的方法都是在函数内部定义，无法实现函数复用</p>\n<h3>组合继承</h3>\n<p>将原型链和构造函数的技术组合到一块，使用原型链实现对原型属性和方法的继承，通过构造函数来实现对实例属性的继承；</p>\n<pre><code>function Animal(species) {\n    this.species = species;\n    this.hobits = ['eat', 'sleep', 'play'];\n}\nAnimal.prototype.getSpecies = function() {\n    console.log(this.species);\n};\n\nfunction Cat(species, name) {\n    Animal.call(this, species);\n    this.name = name;\n}\n\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\nCat.prototype.sayName = function() {\n    console.log(this.name);\n};\n\nconst nimo = new Cat('Cat', 'nimo');\nnimo.hobits.push('meow');\nconsole.log(nimo.hobits);\nnimo.getSpecies();\nnimo.sayName();\n\nconst niya = new Cat('Cat', 'niya');\nconsole.log(niya.hobits);\nniya.getSpecies();\nniya.sayName();\n</code></pre>\n<h4>缺点</h4>\n<p>父类构造函数执行两遍，子类实例和其原型上会存在相同的属性，虽然修改同属性的子类值，不会影响原型，但原型上的属性其实是没有必要的。</p>\n<h3>原型式继承</h3>\n<p>借助原型可以基于已有的对象创建新对象，同时不必因此创建自定义类型</p>\n<pre><code>function object(o) {\n    function Noop(){}\n    Noop.prototype = o;\n    return new Noop();\n}\n\nconst animal = {\n    property: 'some property',\n    hobits: ['eat', 'sleep', 'play']\n};\n\nconst nimo = object(animal);\nnimo.name = 'nimo'\nnimo.hobits.push('meow'); // 引用类型受影响\nconsole.log(nimo.name, nimo.hobits);\n\nconst niya = object(animal);\nconsole.log(niya.name, niya.hobits);\n</code></pre>\n<p>es5 规范了原型式继承，使用 Object.create()方法，与 object 函数类似，行为是浅复制。</p>\n<p>缺点：引用类型的属性会造成属性共享的问题，</p>\n<h3>寄生式继承</h3>\n<p>与原型式继承紧密相关，创建一个仅用于封装继承的过程的函数，函数内部通过某种方式来实现增强对象。</p>\n<pre><code>function parasitic(o) {\n    const clone = Object.create(o) // 使用原型式继承函数object也可以\n    clone.sayHi = function() {\n        console.log('Hi');\n    }\n\n    return clone;\n}\n\nconst animal = {\n    property: 'some property',\n    hobits: ['eat', 'sleep', 'play']\n};\n\nconst nimo = parasitic(animal);\nconsole.log(nimo.sayHi);\n</code></pre>\n<p>缺点：共享属性的问题，封装过程中的函数无法复用</p>\n<h3>寄生式组合继承</h3>\n<p>使用组合继承+寄生式继承</p>\n<pre><code>function inheritProperty(child, farther) {\n    const prototype = Object.create(farther.prototype);\n    prototype.constructor = child;\n    child.prototype = prototype;\n}\n\nfunction Animal(species) {\n    this.species = species;\n    this.hobits = ['eat', 'sleep', 'play'];\n}\nAnimal.prototype.getSpecies = function() {\n    console.log(this.species);\n};\n\nfunction Cat(species, name) {\n    Animal.call(this, species);\n    this.name = name;\n}\n\ninheritProperty(Cat, Animal);\nCat.prototype.sayName = function() {\n    console.log(this.name);\n};\n\nconst nimo = new Cat('Cat', 'nimo');\nnimo.hobits.push('meow');\nconsole.log(nimo.hobits);\nnimo.getSpecies();\nnimo.sayName();\n\nconst niya = new Cat('Cat', 'niya');\nconsole.log(niya.hobits);\nniya.getSpecies();\nniya.sayName();\n</code></pre>\n<p>只调用一次构造函数，避免了在子类 property 上创建不必要的属性。</p>","frontmatter":{"title":"JavaScript里的继承"}}},"pageContext":{"slug":"/blog/2019/jsinherit/"}}}