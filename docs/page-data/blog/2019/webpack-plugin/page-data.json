{"componentChunkName":"component---src-templates-blog-js","path":"/blog/2019/webpack-plugin","result":{"data":{"markdownRemark":{"html":"<h3>背景</h3>\n<p>为什么需要 plugin？webpack 作为一个前端构建工具，自身只能处理 javascript 文件，对于其他类型的文件并不支持；但是前端项目除了 javascript，还包括 css、image、font 等资源，对于这类资源的处理，是通过 loader 实现的；而 plugin 所能实现的功能，远超于 loader，比如<strong>html-webpack-plugin</strong>可以指定 html 模板，提供 options 用来修饰 title、meta、以及是否要压缩 html 等功能；这些功能的实现都是通过 plugin 机制实现的，通过 webpack 提供的内置 api，可以在构建的整个生命周期内触及资源以及相关的配置信息，通过对资源进行相应的处理，来达到自己预期的目的。\nwepack 的插件理解\n仅保留核心，其他功能全部使用组合，这样做的好处是灵活，按需配置；其中有 loader 和 plugin 两个概念，webpack 只能处理 js 文集，对于其他文件，就需要通过 loader 来转换；而 plugin 能够在整个的 webpack 期间对资源进行处理；</p>\n<p>同样在 gatsby 中，存在相似的理念，使用 fileSystem 读取文件系统下的内容，然后使用 transform plugin 来转换（比如把 md 文件转换为 html 字符串）</p>\n<h3>如何实现</h3>\n<p>定义一个构造函数，并在其原型上定义一个 apply 方法</p>\n<pre><code>// options可选对象\nfunction CustomPlugin(options) {\n  // init options\n  this.options = options;\n}\n\nCustomPlugin.prototype.apply = function(compiler) {\n  // your code here\n}\n</code></pre>\n<p>可以使用 Class 语法糖来实现同样的功能</p>\n<pre><code>class CustomPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n\n  aplly(compiler) {\n    // your code here\n  }\n}\n</code></pre>\n<p>对比官方给出的 logger 的 demo</p>\n<pre><code>const pluginName = 'ConsoleLogOnBuildWebpackPlugin';\n\nclass ConsoleLogOnBuildWebpackPlugin {\n  apply(compiler) {\n    // ***hooks提供一系列的方法***\n    compiler.hooks.run.tap(pluginName, compilation => {\n      console.log('The webpack build process is starting!!!');\n    });\n  }\n}\n</code></pre>\n<p>上面的代码，仅仅是一个雏形，要真正实现一个 plugin 需要完善 aplly 方法里的逻辑，首先是需要了解 compiler 和 compilation 的概念，其次是要熟悉 plugin 机制里面暴露给开发者的相关 api；（ps 待补充）</p>","frontmatter":{"title":"webpack-plugin-develop"}}},"pageContext":{"slug":"/blog/2019/webpack-plugin/"}}}