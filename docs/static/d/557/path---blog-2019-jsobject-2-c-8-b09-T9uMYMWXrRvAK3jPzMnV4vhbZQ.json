{"data":{"markdownRemark":{"html":"<p>对象是 JavaScript 里重要的知识点，梳理一下几种创建对象的方法。</p>\n<p>常见的创建对象的方式，适合单个对象的创建</p>\n<h3>Object 构造函数</h3>\n<pre><code>const obj = new Object();\nobj.key = value;\n\n// 由于原型的存在，obj.constructor === Object，所以也会有使用如下方法的时候\nconst another = new obj.constructor(); // deepClone时如果克隆的值是数组或者对象时，可以使用该方法不用去做判断\n</code></pre>\n<h3>对象字面量</h3>\n<pre><code>// 常用的方式，简洁\nconst obj = {\n    key: value\n};\n</code></pre>\n<h3>Object.create</h3>\n<p>新创建的对象可以继承另一个对象的属性和方法\n特例： Object.create(null) 会返回一个真正意义上的空对象，没有原型，可以用作字典</p>\n<pre><code>const proto = {\n    like: 'moive'\n};\n\nconst obj = Object.create(proto);\n</code></pre>\n<p>以上方法虽然能创建对象，但是在创建多个时，会产生大量的重复代码，所以有产生了一些模式来创建对象</p>\n<h3>工厂模式</h3>\n<p>特点：利用函数来封装，以特定的接口创建对象的细节</p>\n<pre><code>function createPerson(name, age, job) {\n    const res = new Object();\n    res.name = name;\n    res.age = age;\n    res.job = job;\n    res.sayName = function() {\n        console.log(this.name);\n    }\n    return res;\n}\n\nconst p1 = createPerson('Zed', 20, 'teacher');\n</code></pre>\n<p>缺点：无法知道对象的类型（无法使用 instanceof 来判断实例的类型）</p>\n<h3>构造函数</h3>\n<p>类似在 JavaScript 中存在原生的构造函数（Object、Array），我们可以利用自定义的构造函数来创建对象\n特点：可以使用 instanceof 来判断实例类型</p>\n<pre><code>function Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function() {\n        console.log(this.name);\n    }\n}\nconst p1 = new person('Zed', 20, 'teacher');\n</code></pre>\n<p>缺点：实例上的每个方法都需要在生成时创建一遍</p>\n<h3>原型模式</h3>\n<p>由于每一个函数都有一个 prototype 属性，可以利用该属性来保存共享的属性和方法\n特点： 所有的属性和方法都是共享的</p>\n<pre><code>function Person() {}\nPerson.prototype.name = 'Zed';\nPerson.prototype.age = 20;\nPerson.prototype.job = 'teacher';\nPerson.prototype.sayName = function() {\n    console.log(this.name);\n};\nconst p1 = new Person();\n</code></pre>\n<p>缺点： 省略了构造函数的初始化参数，共享的特性导致引用类型的属性很容易被污染（灾难级）；</p>\n<h3>组合模式</h3>\n<p>组合使用构造函数模式和原型模式，构造函数模式用于定义实例的属性，原型模式用于定义方法和共享的属性；\n特点：集两种模式的长处为一体,使用广泛</p>\n<pre><code>function Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n}\n\nPerson.prototype.sayName = function() {\n    console.log(this.name);\n};\nconst p1 = new Person('Tom', 29, 'Software Engineer');\n</code></pre>\n<h3>动态原型模式</h3>\n<p>为什么会存在这种？其他 oo 的开发人员会对构造函数和原型产生困惑，所以产生了这种模式\n特点：把所有信息都封装在构造函数里，在构造函数里面进行原型的初始化操作</p>\n<pre><code>function Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    if(typeof this.sayName !== 'function') {\n        Person.prototype.sayName = function() {\n            console.log(this.sayName);\n        };\n    }\n}\nconst p1 = new Person('Tom', 29, 'Software Engineer');\n</code></pre>\n<p>在构造函数里面将方法添加到原型上面，方法仅在第一次执行时绑定（需要理解 new 操作符）</p>\n<h3>寄生构造函数模式</h3>\n<p>在前面几种模式不适用的情况下使用\n特点：工厂模式的实现+new 操作符</p>\n<pre><code>function Person(name, age, job) {\n    var res = new Object();\n    res.name = name;\n    res.age = age;\n    res.job = job;\n    res.sayName = function() {\n        console.log(this.name);\n    };\n    return res;\n}\nconst p1 = new person('Tom', 20, 'worker');\n</code></pre>\n<p>缺点： 无法使用 instanceof 判断类型</p>\n<h3>稳妥构造函数模式</h3>\n<p>稳妥对象：没有公共属性，方法不引用 this；\n特点：使用闭包，安全性高</p>\n<pre><code>function Person(name, age, job) {\n    const res = new Object();\n    // todo 设置一些私有变量和方法\n    res.sayName = function() {\n        console.log(name);\n    };\n    return res;\n}\nconst p1 = new Person('Tom', 20, 'driver');\n</code></pre>\n<h3>Class</h3>\n<p>es6 使用 Class 来实现类，使用 extends 实现子类继承父类</p>\n<pre><code>Class Person {\n    constructor(name, age, job) {\n        this.name = name;\n        this.age = age;\n        this.job = job;\n    }\n    sayName() {\n        console.log(this.name);\n    }\n}\n</code></pre>","frontmatter":{"title":"JavaScript里创建对象"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2019/jsobject/"}}